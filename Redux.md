# Redux Toolkit Learning Path

> Redux is for **global, shared, async state**, not UI state.

---

## ğŸ§­ Redux Toolkit

### 1ï¸âƒ£ Installation

### 2ï¸âƒ£ Create Store

### 3ï¸âƒ£ Connect Store to React

```jsx
<Provider store={store}>
  <App />
</Provider>
```

### 4ï¸âƒ£ Create Slice (core concept)

- `createSlice`
- `name`, `initialState`, `reducers`, `actions`, `reducer`
- `slice.actions` and `slice.reducer` are auto generated by RTK

### 5ï¸âƒ£ Add Slice to Store

- Import reducer
- Define state key

### 6ï¸âƒ£ Use Redux inside a React component

- **Read:** `useSelector`
- **Write:** `useDispatch`
- Example:

```js
const value = useSelector((state) => state.counter.value);
const dispatch = useDispatch();
dispatch(increment());
```

**Explanation:**

- `state` = entire Redux store
- `counter` = key you used in store.js
- `value` = from initialState
- `dispatch()` = only way to change Redux state
- Components **never** call reducers directly

**Dispatch flow:**

```
dispatch(increment())
â†’ action created { type: 'counter/increment' }
â†’ store receives action
â†’ counter reducer runs
â†’ state.counter.value updates
â†’ component re-renders
```

**Important:**

- `increment()` is an action creator
- Not calling it as `dispatch(increment)` will break Redux
- `incrementByAmount(5)` â†’ `5` becomes `action.payload`
- Reducer reads `action.payload`
- State updates based on external data

### ğŸ” Step 7 â€” Redux Data Flow

- Redux always follows **ONE-WAY data flow:**

```
UI â†’ dispatch(action)
Action created (RTK auto) â†’ reducer runs â†’ store update â†’ UI re-renders
```

- `dispatch()` is the only way to change Redux state
- Reducers are pure logic holders
- UI never talks to reducer directly

### ğŸ§  KEY RULE (REMEMBER THIS)

- Component never changes state
- Reducer never touches UI
- Store is the single source of truth

### âš¡ Step 8 â€” Async Redux with createAsyncThunk

- Redux cannot handle async logic inside reducers
- Async work goes to thunks
- `createAsyncThunk` gives 3 states automatically: `pending`, `fulfilled`, `rejected`
- Async state usually needs: `data`, `loading`, `error`

### ğŸ”¹ Memoized Selectors

- `createSelector` is used for **optimizing rendering** of Redux state
- Memoizes previous values and only recalculates when dependencies change
- Selector = read
- `createSelector` = smart read with memory

### ğŸ”´ RTK Query (Conceptual Changes)

**Before (Thunk):**

- You manually handled: `loading`, `error`, `extraReducers`, `createAsyncThunk`

**With RTK Query:**

- Redux auto-manages `loading`, `error`, caching, refetching
- You do **not** write reducers for API data
